#!/usr/bin/env perl
use warnings;
use strict;
use FindBin;
use lib "$FindBin::Bin/lib";
use Getopt::Long;
use Term::ANSIColor;
use IO::Select;
use IPC::Open3;
use File::Find;
use File::Spec;
use File::Copy qw(cp);
use File::Basename;
use Cwd qw(abs_path);
use VircadiaBuilder::Common;
use POSIX ();


$| = 1;

my $prev_len = 0;
my $inst_copied = 0;
my $inst_skipped = 0;
my $inst_deleted = 0;
my %installed;




my $data;


# Valid build targets for the makefile
my $all_targets = {
	'domain-server'       => { service => 1, service_desc => "Vircadia Domain Server"    , service_args => [] },
	'assignment-client'   => { service => 1, service_desc => "Vircadia Assignment Client", service_args => ["-n", "6"] },
	'ice-server'          => { service => 1, service_desc => "Vircadia ICE Server"       , service_args => [] },
	'interface'           => { service => 0 },
	'atp-client'          => { service => 0 },
	'oven'                => { service => 0 },
	'nitpick'             => { service => 0 },
	'skeleton-dump'       => { service => 0 },
	'ac-client'           => { service => 0 },
	'ktx-tool'            => { service => 0 },
	'ice-client'          => { service => 0 },
	'gpu-frame-player'    => { service => 0 },
	'vhacd-util'          => { service => 0 }
};

# Libraries that don't go into an AppImage.
# Taken from https://github.com/AppImage/pkg2appimage/blob/master/excludelist
# Trimmed down a bit, as I want a minimum of requirements for installation.
#
# libnss3.so and libnssutil3.so weren't part of the original list and added
# to fix "Error initializing NSS with a persistent database"

my @excluded_system_libs = (
	qr/^ld-linux\.so\.2/,
	qr/^ld-linux-x86-64\.so\.2/,
#	qr/^libanl\.so\.1/,
#	qr/^libasound\.so\.2/,
#	qr/^libBrokenLocale\.so\.1/,
#	qr/^libcidn\.so\.1/,
#	qr/^libcom_err\.so\.2/,
	qr/^libc\.so\.6/,
	qr/^libdl\.so\.2/,
	qr/^libdrm\.so\.2/,
	qr/^libEGL\.so\.1/,
#	qr/^libexpat\.so\.1/,
	qr/^libfontconfig\.so\.1/,
	qr/^libfreetype\.so\.6/,
	qr/^libfribidi\.so\.0/,
#	qr/^libgbm\.so\.1/,
	qr/^libgcc_s\.so\.1/,
#	qr/^libgdk_pixbuf-2\.0\.so\.0/,
#	qr/^libgio-2\.0\.so\.0/,
	qr/^libglapi\.so\.0/,
	qr/^libGLdispatch\.so\.0/,
#	qr/^libglib-2\.0\.so\.0/,
	qr/^libGL\.so\.1/,
	qr/^libGLX\.so\.0/,
#	qr/^libgmp\.so\.10/,
#	qr/^libgobject-2\.0\.so\.0/,
#	qr/^libgpg-error\.so\.0/,
#	qr/^libharfbuzz\.so\.0/,
#	qr/^libICE\.so\.6/,
#	qr/^libjack\.so\.0/,
	qr/^libm\.so\.6/,
	qr/^libmvec\.so\.1/,
	qr/^libnss_compat\.so\.2/,
	qr/^libnss_dns\.so\.2/,
	qr/^libnss_files\.so\.2/,
	qr/^libnss_hesiod\.so\.2/,
	qr/^libnss_nisplus\.so\.2/,
	qr/^libnss_nis\.so\.2/,
	qr/^libnss3\.so/, #added - fixes crash in libsoftokn3.so
	qr/^libnssutil3\.so/, #added
#	qr/^libp11-kit\.so\.0/,
#	qr/^libpango-1\.0\.so\.0/,
#	qr/^libpangocairo-1\.0\.so\.0/,
#	qr/^libpangoft2-1\.0\.so\.0/,
	qr/^libpthread\.so\.0/,
	qr/^libresolv\.so\.2/,
	qr/^librt\.so\.1/,
#	qr/^libSM\.so\.6/,
	qr/^libstdc\+\+\.so\.6/,
#	qr/^libthai\.so\.0/,
	qr/^libthread_db\.so\.1/,
#	qr/^libusb-1\.0\.so\.0/,
	qr/^libutil\.so\.1/,
#	qr/^libuuid\.so\.1/,
#	qr/^libX11\.so\.6/,
#	qr/^libxcb-dri2\.so\.0/,
#	qr/^libxcb-dri3\.so\.0/,
#	qr/^libxcb\.so\.1/,
#	qr/^libz\.so\.1/
);

my $appimagetool_release = 13;
my $appimagetool_url = "https://github.com/AppImage/AppImageKit/releases/download/${appimagetool_release}/appimagetool-x86_64.AppImage";


my @x11_lib_paths = ("/usr/lib64", "/usr/X11R6/lib64", "/usr/lib/x86_64-linux-gnu", "/usr/lib");
my @system_qt_paths = ('/usr/lib64/cmake', '/usr/lib/x86_64-linux-gnu/cmake');

# Amount of RAM needed to build Vircadia, per compiler process.
my $mem_per_core_vircadia = 1 * 1024 * 1024;

# Qt has a build stage that consumes a huge amount of RAM. Be a bit conservative here.
my $mem_per_core_qt     = 1.2 * 1024 * 1024;

my $repo         = "https://github.com/vircadia/vircadia";
my $qt_repo      = "git://code.qt.io/qt/qt5.git";
my $repo_tag     = "master";
my $repo_tag_path = "";

my $root_dir     = "$ENV{HOME}/Vircadia";
my $inst_dir     = "$root_dir/install"; # Where files will be installed
my $binary_dir   = $inst_dir;           # Where the final binaries are found

my $rel_type     = "DEV"; # DEV by default.
my $rel_no       = "";
my $build_no     = "";

my $build_cores;
my $build_cores_qt;

my $desktop;
my $distro;

my ($opt_keep_source, $opt_auto, $opt_build_qt, $opt_build, $opt_sys_qt, $opt_skip_build, $opt_skip_systemd_restart, $opt_no_modify_rpath, $opt_skip_install, $opt_make_appimage, $opt_install_deps_only);
my ($opt_qt_debug, $opt_qt_debug_info);
my ($cmd_help, $cmd_get_supported, $cmd_get_source_deps, $cmd_get_qt_deps, $cmd_get_system_qt_deps, $cmd_get_qt_version, $cmd_get_qt_patches, $cmd_make_pkglist);

$opt_build = "client";
my @build_list;


GetOptions(
	"keep-source|K"          => \$opt_keep_source,
	"help|h"                 => \$cmd_help,
	"auto|y"                 => \$opt_auto,
	"repo|r=s"               => \$repo,
	"tag|t=s"                => \$repo_tag,
	"release-type=s"         => \$rel_type,
	"release-number=s"       => \$rel_no,
	"build-number=s"         => \$build_no,
	"destdir|d=s"            => \$root_dir,
	"cores|j=i"              => \$build_cores,
	"qt-cores|J=i"           => \$build_cores_qt,
	"collect-info|C"         => \$VircadiaBuilder::Common::collect_system_info,
	"distro|D=s"             => \$distro,
	"build-qt|B"             => \$opt_build_qt,
	"build|U=s"              => \$opt_build,
	"get-supported"          => \$cmd_get_supported,
	"get-source-deps=s"      => \$cmd_get_source_deps,
	"get-qt-deps=s"          => \$cmd_get_qt_deps,
	"get-system-qt-deps=s"   => \$cmd_get_system_qt_deps,
	"get-qt-version=s"       => \$cmd_get_qt_version,
	"get-qt-patches=s"       => \$cmd_get_qt_patches,
	"make-pkglist"           => \$cmd_make_pkglist,
	"make-appimage|A"        => \$opt_make_appimage,
	"use-system-qt|S"        => \$opt_sys_qt, # Obsoleted, ignored
	"skip-build"             => \$opt_skip_build,
	"skip-install"           => \$opt_skip_install,
	"skip-systemd-restart"   => \$opt_skip_systemd_restart,
	"no-modify-rpath"        => \$opt_no_modify_rpath,
	"qt-debug"               => \$opt_qt_debug,
	"qt-debug-info"          => \$opt_qt_debug_info,
	"install-deps-only"      => \$opt_install_deps_only
) or help(1);


@build_list = parse_build_option($opt_build);
load_data();


help(1) if ($cmd_help);

get_supported() if ( $cmd_get_supported );
get_conf( 'source_dependencies', $cmd_get_source_deps ) if ( $cmd_get_source_deps );
get_conf( 'qt_source_dependencies', $cmd_get_qt_deps )  if ( $cmd_get_qt_deps );
get_conf( 'system_qt_dependencies', $cmd_get_system_qt_deps ) if ( $cmd_get_system_qt_deps );
get_conf( 'qt_version', $cmd_get_qt_version )           if ( $cmd_get_qt_version );
get_conf( 'qt_patches', $cmd_get_qt_patches )           if ( $cmd_get_qt_patches );
make_pkglist()                                          if ( $cmd_make_pkglist );



init_log();


$build_cores    //= calculate_cores("Vircadia", $mem_per_core_vircadia);
$build_cores_qt //= calculate_cores("Qt", $mem_per_core_qt);
$desktop        //= get_desktop();
$distro         //= detect_distro();


if ( !exists $data->{$distro} ) {
	fatal("No configuration for $distro, distribution unsupported.");
}

my $DD = $data->{$distro};

my %PACKAGES = get_package_list();
set_environment();
install_missing_packages();

exit(0) if ( $opt_install_deps_only );

import_nvm_environment();
collect_info();

# We need to build Qt if:
# A. The user explicitly wants to build it
# B. Both of these are the case:
#    * There's no binary package
#    * System Qt is not supported.
my $need_to_buld_qt = $opt_build_qt || (!$DD->{has_binary_qt_package}  && !$DD->{system_qt_dependencies});

unless($opt_skip_build) {
	get_source();
	install_qt() if ($need_to_buld_qt);
	build();
}

setup_qt() if ($need_to_buld_qt);
adjust_library_paths() unless ($opt_no_modify_rpath);

if ( $opt_make_appimage ) {
	download_appimage_tool();
	install_into_appimage();
} else {
	install() unless ($opt_skip_install);
	setup_scripts();
	setup_services();
	setup_desktop();
}

sub load_data {
	my $confpath = "$FindBin::Bin/distros";
	opendir(my $dfh, $confpath) or die "Can't find distros directory at $confpath";
	while(my $filename = readdir($dfh)) {
		next if ( -d "$confpath/$filename" );
		if ( $filename =~ /.cfg$/ ) {
			my $distro_name = basename($filename, ".cfg");
			$data->{$distro_name} = do("$confpath/$filename");
		}
	}
}

sub detect_distro {
	info("Detecting distribution... ");

	if ( -f "/etc/os-release" ) {
		my @release_info = readfile("/etc/os-release");
		my %release_data;

		debug("Parsing /etc/os-release...\n");
		foreach my $line (@release_info) {
			my ($k, $v) = $line =~ /^(\w+)=(.*?)$/;

			$v =~ s/^"//;
			$v =~ s/"$//;

			$release_data{$k} = $v;
			debug("\t$k => '$v'\n");
		}

		my $id          = $release_data{ID} . "-" . $release_data{VERSION_ID};
		my $pretty_name = $release_data{PRETTY_NAME} // ( $release_data{NAME} . " " . $release_data{VERSION} );

		if ( $release_data{ID} eq "opensuse-tumbleweed" ) {
			$id = $release_data{ID};

			# Opensuse Tumbleweed is a rolling release, and VERSION_ID is a timestamp, so it changes
			# far too often. For now we're just going to assume that people stay up to date and only
			# supporting the latest is needed.
		}

		info_ok("$pretty_name ($id)\n");
		return $id;
	}

	fatal("Failed to detect distribution! Couldn't find /etc/os-release.");
}



sub get_package_list {
	info("Getting the package list... ");
	my @packages;
	if ( $DD->{package_manager} eq "dnf" || $DD->{package_manager} eq "yum" || $DD->{package_manager} eq "zypper" ) {
		@packages = read_from_cmd("rpm", "-qa", "--qf", "%{NAME}\\n");
	} elsif ( $DD->{package_manager} eq "apt" ) {
		@packages = read_from_cmd("dpkg-query", "--show", "-f", "\${Package}\n");
	} elsif ( $DD->{package_manager} eq "pacman" ) {
		@packages = read_from_cmd("pacman", "-Qq");
	} elsif ( $DD->{package_manager} eq "none" ) {
		# Nothing
	} else {
		fatal("Internal error: unknown package manager " . $DD->{package_manager});
	}

	chomp @packages;

	info_ok("done.\n");
	return map { $_ => 1 } @packages;
}

sub set_environment {
	if ( exists $DD->{environment} ) {
		info("Setting environment... ");

		foreach my $var ( keys %{ $DD->{environment} } ) {
			$ENV{$var} = $DD->{environment}->{$var};
			info_ok("$var ");
		}

		info_ok("\n");
	}

}

sub install_missing_packages {
	my @required_packages = @{$DD->{source_dependencies}};

	info("Checking Qt availability...");

	if ( $DD->{system_qt_dependencies} ) {
		info_ok(" system Qt available.\n");
		push @required_packages, @{ $DD->{system_qt_dependencies}};
	} elsif ( $DD->{has_binary_qt_package}) {
		info_ok(" binary Qt package available.\n");
	} else {
		push @required_packages, @{ $DD->{qt_source_dependencies}};

		warning(" no system Qt support, nor binary package\n\n");

		warning("System Qt is not supported on your system, and there is no binary\n");
		warning("Qt package available either.\n\n");
		warning("This script will build it for you, but it can take a long time,\n");
		warning("up to several hours, depending on hardware capabilities.\n\n");
		warning("Fortunately, it only needs to be built once.\n\n");
	}

	if ( $opt_make_appimage ) {
		push @required_packages, @{ $DD->{appimage_dependencies} };
	}

	info("Checking if any packages need installing... ");


	my @missing = grep { !exists $PACKAGES{$_} } @required_packages;


	if ( @missing ) {
		print scalar(@missing) . " additional packages needed: " . join(", ", @missing) . "\n";

		if ( $DD->{package_manager} eq "dnf" ) {
			sudo_run("dnf", "install", "-y", @missing);
		} elsif ( $DD->{package_manager} eq "yum" ) {
			sudo_run("yum", "install", "-y", @missing);
		} elsif ( $DD->{package_manager} eq "apt" ) {
			$ENV{DEBIAN_FRONTEND} = 'noninteractive';
			sudo_run("apt-get", "update");
			sudo_run("--preserve-env=DEBIAN_FRONTEND", "apt-get", "install", "-y", @missing);
		} elsif ( $DD->{package_manager} eq "pacman" ) {
			sudo_run("pacman", "-S", "--noconfirm", @missing);
		} elsif ( $DD->{package_manager} eq "zypper" ) {
			sudo_run("zypper", "--non-interactive", "install", @missing);
		} elsif ( $DD->{package_manager} eq "none" ) {
			# Nothing
		} else {
			fatal("Internal error: unknown package manager " . $DD->{package_manager});
		}

		info_ok("\nPackages have been installed, please run $0 again.\n\n");
		exit(0);
	} else {
		info_ok("no.\n");
	}
}

sub import_nvm_environment {
	# Amazon Linux 2 is a huge pain to deal with. The official instructions as per:
	# https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/setting-up-node-on-ec2-instance.html
	# require running a random shell script off the web, and sourcing a script to get the environment vars.
	#
	# For the sake of user friendliness we'd like to avoid making the user modify their profile.
	#
	# So we're counting on that install_amazon_linux_deps.sh did the installation work, and then we'll try
	# and import the environment into our process by calling nvm.sh, env, and parsing that.

	info("Checking for NPM... ");
	if (!-x "/usr/bin/npm" && !-x "/usr/local/bin/npm") {
		if ( -f "$ENV{HOME}/.nvm/nvm.sh" ) {
			info_ok("NVM found, importing environment... ");

			my $var_data = run({keep_buf => 1}, "source \"$ENV{HOME}/.nvm/nvm.sh\" && env --null");
			foreach my $var_line (split(/\0/, $var_data)) {
				chomp $var_line;
				my ($k, $v) = split(/=/, $var_line);

				if ( $k =~ /^NVM/ || $k eq "PATH" ) {
					# Import NVM_* and PATH variables to our local environment
					info_ok("$k ");
					debug("$k => $v");
					$ENV{$k} = $v;
				}
			}

			if ( $ENV{PATH} =~ /\.nvm/ ) {
				# Sanity check
				info_ok("imported, looks good.\n");
			} else {
				warning("imported, may not have worked.\n");
			}
		} else {
			warning("Not found installed, NPM not found. Build may fail.\n");
		}
	} else {
		info_ok("Found installed, all good.\n");
	}
}


sub collect_info {
	require Term::ReadLine;
	info("\n");
	important("Everything seems to be in order. I am going to ask you some questions now.\n");
	important("The defaults should be just fine. Simply press ENTER to accept the suggested\n");
	important("value.\n\n");

	my $rl = Term::ReadLine->new('vircadia_setup');
	my $ok = $opt_auto ? "yes" : "no";

	while($ok ne "yes") {
		$repo            = $rl->readline("Git repository             : ", $repo);
		$repo_tag        = $rl->readline("Git tag                    : ", $repo_tag);
		$rel_type        = $rl->readline("Release type               : ", $rel_type);
		$rel_no          = $rl->readline("Release number             : ", $rel_no);
		$build_no        = $rl->readline("Build number               : ", $build_no);
		$root_dir        = $rl->readline("Installation dir           : ", $root_dir);
		$build_cores     = $rl->readline("CPU cores to use for Vircadia: ", $build_cores);
		$build_cores_qt  = $rl->readline("CPU cores to use for Qt5   : ", $build_cores_qt);

		info("\n");
		$ok = $rl->readline("If the above is okay, say 'yes' to begin installation: ", "yes");
	}

	if ( defined $rel_no ) {
		$ENV{RELEASE_NUMBER} = $rel_no;
	}

	if ( defined $build_no ) {
		$ENV{BUILD_NUMBER} = $build_no;
	}

	if ( lc($rel_type) eq "production" ) {
		$ENV{RELEASE_TYPE} = 'PRODUCTION';
		$ENV{PRODUCTION_BUILD} = 1;
		$ENV{USE_STABLE_GLOBAL_SERVICES} = 1;
		$ENV{BUILD_GLOBAL_SERVICES} = 'STABLE';
	}

	if ( lc($rel_type) eq "pr" ) {
		$ENV{RELEASE_TYPE} = 'PR';
		$ENV{PR_BUILD} = 1;
	}

	if ( lc($rel_type) eq "dev" ) {
		$ENV{RELEASE_TYPE} = 'DEV';
		$ENV{DEV_BUILD} = 1;
		$ENV{BUILD_GLOBAL_SERVICES} = 'DEVELOPMENT';
	}

	$repo_tag_path = $repo_tag;
	$repo_tag_path =~ s/\W/_/g;

	$inst_dir = "$root_dir/install_$repo_tag_path";
	$binary_dir = $opt_skip_install ? "$root_dir/build" : $inst_dir;
}


sub get_source {
	info("\n\n");
	important("############################################################\n");
	important("# Starting installation\n");
	important("############################################################\n");
	info("\n");

	mkdir($root_dir);

	get_source_from_git($repo, "source", $repo_tag, no_submodules => 1);

	if ( $opt_sys_qt ) {
		info("Applying System Qt patch... ");
		chdir("$root_dir/source");
		run("patch", "-p1", "-i", "debian/patches/hifi_use_system_qt.diff");
		info_ok("done.\n");
	}
}

sub build {
	info("\n\n");
	important("############################################################\n");
	important("# Building\n");
	important("############################################################\n");
	info("\n");


	if ( $DD->{system_qt_dependencies} ) {
		important("Using system Qt\n");
		$ENV{VIRCADIA_USE_SYSTEM_QT} = 1;
	} elsif ( check_qt_install() ) {
		important("Using compiled Qt\n");
		$ENV{QT_CMAKE_PREFIX_PATH}="$root_dir/qt5-install/lib/cmake";

		# hifi_qt.py in the master merge branch looks for Qt in:
		# $HIFI_QT_BASE/$VIRCADIA_USE_QT_VERSION/qt5-install
		#
		# We do a horrid hack here, where $VIRCADIA_USE_QT_VERSION is
		# an empty string, but still has a value, and $HIFI_QT_BASE
		# points to the root dir, where a qt5-install directory happens
		# to exist.
		#
		# This will be redone later, once the merge is complete and a
		# less ugly way of specifying an external Qt can be introduced.
		$ENV{VIRCADIA_USE_PREBUILT_QT}=1;
		$ENV{VIRCADIA_USE_QT_VERSION}="";
		$ENV{HIFI_QT_BASE} = "$root_dir";

		# Finally, the single, clean solution to the issue, after PR #936
		# The above is obsolete, and can be removed after a while.
		# Suggested cleanup date: Jan 1, 2022.
		$ENV{VIRCADIA_QT_PATH} = "$root_dir/qt5-install";
	}


	$ENV{HIFI_VCPKG_BASE} = "$root_dir/vcpkg";

	if ( -d "$root_dir/build" ) {
		run("rm", "-rf", "$root_dir/build");
	}

	mkdir("$root_dir/build");
	chdir("$root_dir/build");

	run($DD->{cmake}, "../source");

	foreach my $target (@build_list) {
		important("Building target $target\n");
		run("make", $target, "-j${build_cores}");
	}

	if (!$opt_sys_qt) {
		# The one in lib/ doesn't have a rpath, which causes quazip to link against system Qt, which causes interface to link against
		# both system Qt and custom Qt. This leads to problems.
		#
		# This probably needs a cmake fix. See https://github.com/vircadia/vircadia/issues/308

		info("Checking for libquazip linking issue... ");
		my ($quazip_in_lib)   = grep { -f $_ && ! -l $_ } glob("$root_dir/build/ext/makefiles/quazip/project/lib/libquazip5.so*");
		my ($quazip_in_build) = grep { -f $_ && ! -l $_ } glob("$root_dir/build/ext/makefiles/quazip/project/build/libquazip5.so*");

		if ( $quazip_in_lib && $quazip_in_build ) {
			my $lib_rpath   = read_from_cmd("patchelf", "--print-rpath", $quazip_in_lib); chomp $lib_rpath;
			my $build_rpath = read_from_cmd("patchelf", "--print-rpath", $quazip_in_build); chomp $build_rpath;

			if ( $lib_rpath eq "" && $build_rpath ne "" ) {
				cp($quazip_in_build, $quazip_in_lib) or fatal("Can't copy $quazip_in_build to $quazip_in_lib");
				info_ok("issue found, corrected\n");
			} else {
				info_ok("everything looks okay\n");
			}
		} else {
			warning("lib/libquazip5.so* not found; ") unless ($quazip_in_lib);
			warning("build/libquazip5.so* not found; ") unless ($quazip_in_build);
			info_ok("skipping\n");
		}
	}

}

sub adjust_library_paths {
	info("\n\n");
	important("############################################################\n");
	important("# Adjusting library paths\n");
	important("############################################################\n");
	info("\n");


	chdir("$root_dir/build");
	find(\&adjust_libs_search_func, "$root_dir/build");

}

sub install {
	info("\n\n");
	important("############################################################\n");
	important("# Installing\n");
	important("############################################################\n");
	info("\n");

	info("Copying files to install directory...\n");


	find({ follow       => 1,
	       follow_skip  => 2,
	       wanted       => sub { install_search_func("$root_dir/build", $inst_dir, "link") }},
	       "$root_dir/build");

	#find({ follow => 1, follow_skip => 2, wanted => \&install_search_func }, "$root_dir/build");

	# Clear line
	info( "\r" . (" " x $prev_len) . "\r");


	info("Cleaning up install directory...");
	find(\&install_clean_func, $inst_dir);
	info_ok("done\n");

	info("Copied : "); info_ok("$inst_copied\n");
	info("Skipped: "); info_ok("$inst_skipped\n");
	info("Deleted: "); info_ok("$inst_deleted\n");




}


sub  install_search_func {
	my ($source, $destination, $method) = @_;

	my $abspath = $File::Find::name;
	my $relpath = File::Spec->abs2rel($abspath, $source);
	my $file = $_;

	info( "\r" . (" " x $prev_len) . "\r". $relpath );
	$prev_len = length($relpath);


	my $keep;
	my $skip;


	# All libraries are to be kept
	$keep = 1 if ( $file =~ /\.so$/ || $file =~ /\.so\.\d+$/ || $file =~ /\.so\.\d+\.\d+/ || $file =~ /\.so\.\d+\.\d+\.\d+/ );


	# Otherwise, nothing from the ext directory is to be kept
	$skip = 1 if ( $relpath =~ /^ext\// );

	$skip = 1 if ( $relpath =~ /.cmake$/ || $relpath =~ /CMake/ || $relpath =~ /_CPack_Packages/ );

	$skip = 1 if ( $relpath =~ "Makefile" );

	$skip = 1 if ( $relpath =~ /_autogen/ );

	$skip = 1 if ( $relpath =~ /\.h$/ || $relpath =~ /\.cpp$/ );

	$skip = 1 if ( $relpath =~ /_env/ );

	$skip = 1 if ( $relpath =~ /interface_manifest.txt/ );

	if ( $keep || !$skip) {
		if ( -f $abspath ) {
			my $reldir  = dirname($relpath);
			debug("COPY: '$abspath' => '$destination/$relpath'\n");

			mkdir_path("$destination/$reldir");
			unlink("$destination/$relpath") if ( -e "$destination/$relpath" );

			if ( -l $abspath ) {
				# Turns out that trying to make a hardlink of a symlink copies the symlink
				if ( $method eq "copy" ) {
					symlink(readlink($abspath), "$destination/$relpath");
				} elsif ( $method eq "link" ) {
					link(readlink($abspath), "$destination/$relpath") or die "Can't link " . readlink($abspath) . " to $destination/$relpath: $!";
				} else {
					fatal("Unrecognized install method: $method");
				}
			} else {
				if ( $method eq "copy" ) {
					cp($abspath, "$destination/$relpath") or die "Can't copy $abspath to $destination/$relpath: $!";
				} elsif ( $method eq "link" ) {
					link($abspath, "$destination/$relpath") or die "Can't link $abspath to $destination/$relpath: $!";
				} else {
					fatal("Unrecognized install method: $method");
				}
			}

			$installed{$relpath} = 1;
			$inst_copied++;
		}
	} else {
		debug("SKIP: '$abspath'\n");
		$inst_skipped++;
	}
}


sub install_clean_func {
	my $abspath = $File::Find::name;
	my $relpath = File::Spec->abs2rel($abspath, $inst_dir);
	my $file = $_;

	if ( -f $abspath && !exists $installed{$relpath} ) {
		debug("DEL: '$abspath'\n");
		unlink($abspath);
		$inst_deleted++;
	}

}

sub adjust_libs_search_func {
	my $abspath = $File::Find::name;
	my $relpath = File::Spec->abs2rel($abspath, "$root_dir/build");


	# Don't touch cmake things
	return if ( $relpath =~ /CMakeFiles/ );

	# Do not run on Amazon Linux 2 as it does not have patchelf
	if ( -f $abspath && -x $abspath && is_elf($abspath) )  {
		patch_rpath($abspath, $File::Find::dir);
	}
}

sub patch_rpath {
	my ($abs_binpath, $basedir) = @_;

	my $rel_binpath = File::Spec->abs2rel($abs_binpath, "$root_dir/build");



	info("Adjusting $rel_binpath... ");

	my $cur_rpath = read_from_cmd("patchelf", "--print-rpath", $abs_binpath);
	my $new_rpath;

	chomp $cur_rpath;

	my @paths = split(/:/, $cur_rpath);
	my @result;

	my $changes = 0;
	my $failures = 0;
	my $kept = 0;


	foreach my $p (@paths) {
		if ( $p =~ /^\// ) {
			my $new_rel = File::Spec->abs2rel($p, $basedir);
			my $new_val = '$ORIGIN/' . $new_rel;

			debug("\t$p => $new_val\n");

			if ( -e $p && ! -e "$basedir/$new_rel" ) {
				# Sanity check: verify that if the previous path existed,
				# the new one does too.
				warning("Verification failed for $p => $new_val!\n");
				$failures++;
			}

			$changes++;
			push @result, $new_val;
		} else {
			$kept++;
			push @result, $p;
		}
	}


	$new_rpath = join(':', @result);

	if ( !$changes ) {
		info_ok("no change needed\n");
	} else {
		if ( !$failures ) {
			info_ok("$changes changed, $kept kept");
			run("patchelf", "--set-rpath", $new_rpath, $abs_binpath);
			info_ok(", done\n");
		} else {
			error("$changes changed, $kept kept, $failures failures\n");
		}
	}
}

sub is_elf {
	my ($file)  = @_;
	my $buf;
	open(my $fh, '<', $file) or die "Can't open '$file' for reading: $!";
	sysread($fh, $buf, 4);
	close $fh;

	return $buf eq "\x7fELF";
}

sub install_qt {

	if ( check_qt_install() ) {
		important("Skipping Qt5 build. You can remove $root_dir/qt5-install if you want to force it to be rebuilt.\n");
		return;
	}


	info("\n\n");
	important("############################################################\n");
	important("# Starting Qt build\n");
	important("############################################################\n");
	info("\n");


	mkdir($root_dir);
	chdir($root_dir);
#	run("git", "clone", "--recursive", $qt_repo
	get_source_from_git($qt_repo, "qt5",  $DD->{qt_version});


	info("Applying patches...\n");
	chdir("$root_dir/qt5");

	foreach my $patch ( @{ $DD->{qt_patches} } ) {
		run("patch", "-p1", "-i", "$root_dir/source/tools/qt-builder/patches/$patch");
	}

	info("Configuring paths...\n");
	my $xlib_path  = find_lib_dir('libX11.so', @x11_lib_paths);
	my $gllib_path = find_lib_dir('libGL.so', @x11_lib_paths);

	edit_qt_conf(
		"$root_dir/qt5/qtbase/mkspecs/linux-g++-64/qmake.conf",
		QMAKE_LIBDIR_X11    => $xlib_path,
		QMAKE_LIBDIR_OPENGL => $gllib_path
	);



	del_dir("$root_dir/qt5-install");
	del_dir("$root_dir/qt5-build");

	mkdir("$root_dir/qt5-install");
	mkdir("$root_dir/qt5-build");

	chdir("$root_dir/qt5-build");

	# The build process calls Ninja for QtWebEngine, which calculates the number of processes
	# on its own. Fortunately there's an environment variable we can use to rein it in.
	#
	# This var can be found referenced in
	# qtwebengine/src/core/gn_run.pro
	$ENV{NINJAFLAGS} = "-j${build_cores_qt}";

	my @extra_qt_arguments = ();
	push @extra_qt_arguments, "-debug"            if ( $opt_qt_debug );
	push @extra_qt_arguments, "-force-debug-info" if ( $opt_qt_debug_info );

	my $arch = (POSIX::uname)[4];
	my $platform;
    if ( $arch eq "x86_64" ) {
		$platform = "linux-g++-64";
	} elsif ( $arch eq "aarch64" ) {
		$platform = "linux-g++";
	} else {
		fatal("Architecture $arch not supported");
	}

	run("../qt5/configure", "-opensource", "-confirm-license",
		"-platform", $platform,
		@{ $DD->{qt_configure_arguments} },
		@extra_qt_arguments,
		"-prefix", "../qt5-install");

	check_qt_webengine();
	run("make", "-j${build_cores_qt}");
	run("make", "-j${build_cores_qt}", "install");
}

sub setup_qt {
	if (check_qt_install()) {
		# Already installed
		return;
	}

	info("Looking for downloaded Qt's location... ");

	for my $path ("$root_dir/vcpkg", "$ENV{HOME}/hifi") {
		info("$path ");

		my $qt_dir = read_from_cmd("find", $path, "-type", "d", "-name", "qt5-install");
		chomp $qt_dir;

		if ( -d "$qt_dir" ) {
			info_ok("found!\n");

			info("Creating permanent qt dir... ");
			if ( -d "$root_dir/qt5-install" ) {
				run("rm", "-rf", "$root_dir/qt5-install");
			}
			run("cp", "-Rdp", $qt_dir, "$root_dir/qt5-install");

			info_ok("done.\n");
			return;
		}
	}

	fatal("Failed to find Qt dir in $root_dir/vcpkg!");
}

sub setup_scripts {
	foreach my $target (keys %$all_targets) {
		if ( -x "$root_dir/build/$target/$target" ) {
			info("Creating script for $target...");
			create_script($target, "$target/$target");
			info_ok("done.\n");
		}
	}
}

sub setup_services {
	my $services_created;

	foreach my $target (keys %$all_targets) {
		my $t = $all_targets->{$target};
		next unless ($t->{service});

		if ( -x "$root_dir/build/$target/$target" ) {
			info("Creating service for $target...");
			create_service( user => 1, name => $target, args => $t->{service_args}, desc => $t->{service_desc} );
			info_ok("done.\n");

			$services_created = 1;
		}
	}

	unless($opt_skip_systemd_restart) {
		if ( $services_created ) {
			info("Reloading systemd config... ");
			run({ fail_ok => 1 }, "systemctl", "--user", "daemon-reload");

			info_ok("done.\n");
		}
	}
}


sub setup_desktop {
	info("\n\n");
	important("############################################################\n");
	important("# Setting up desktop\n");
	important("############################################################\n");
	info("\n");


	if ( ! -x "$root_dir/build/interface/interface" ) {
		info("interface not built, skipping desktop setup\n");
		return;
	}


	mkdir($desktop);
	create_script("interface", "interface/interface");

	mkdir("$ENV{HOME}/.local");
	mkdir("$ENV{HOME}/.local/share");
	mkdir("$ENV{HOME}/.local/share/applications");
	my $desktop_file = "$ENV{HOME}/.local/share/applications/Vircadia.desktop";

	link("$root_dir/source/interface/icon/interface.ico", "$binary_dir/interface.ico");
	create_desktop_file($desktop_file, "$binary_dir/run_interface", "$binary_dir/interface.ico");

	info("Creating a link in the user's desktop... ");
	mkdir($desktop);
	unlink("$desktop/Vircadia.desktop") if ( -e "$desktop/Vircadia.desktop" );

	if ( symlink($desktop_file, "$desktop/Vircadia.desktop") ) {
		info_ok("done.\n");
	} else {
		warning("failed: $!\n");
	}

	info("Marking desktop icon as trusted...\n");
	run({ fail_ok => 1 }, "gio", "set", $desktop_file, "metadata::trusted", "yes");

	info("Adding to menu...\n");
	run({ fail_ok => 1 }, "xdg-desktop-menu", "install", "--novendor", $desktop_file);

	info_ok("All done!\n");
}

sub create_desktop_file {
	my ($desktop_file, $application, $icon) = @_;

	info("Creating desktop icon for $application... ");
	open(my $dsk, ">", $desktop_file) or fatal("Can't create $desktop_file: $!");
	print $dsk "[Desktop Entry]\n";
	print $dsk "Version=1.0\n";
	print $dsk "Name=Vircadia\n";
	print $dsk "Terminal=false\n";
	print $dsk "Type=Application\n";
	print $dsk "Exec=$application\n";
	print $dsk "Icon=$icon\n" if ($icon);
	print $dsk "Categories=Graphics;AudioVideo;Network;\n";
	close $dsk;
	info_ok("done.\n");
}


sub create_script {
	my ($name, $command) = @_;

	open(my $script, ">", "$root_dir/build/run_$name") or fatal("Can't create $root_dir/build/run_$name: $!");
	my $args = "";

	if ( $command =~ /assignment/ ) {
		$args = "-n 6"
	}

	print $script "#!/bin/bash\n";
	print $script 'SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"' . "\n";

	print $script "export QT_DIR=\$SCRIPT_DIR/../qt5-install\n";
	print $script "export QT_QPA_PLATFORM_PLUGIN_PATH=\$QT_DIR/plugins\n";
	print $script "export LD_LIBRARY_PATH=\$QT_DIR/lib:\$LD_LIBRARY_PATH\n";
	print $script "export PATH=\$QT_DIR/bin:\$QT_DIR/libexec:\$PATH\n";
	print $script "export QTWEBENGINEPROCESS_PATH=\$QT_DIR/libexec/QtWebEngineProcess\n";
	print $script "exec \"\$SCRIPT_DIR/$command\" $args \"\$@\"\n";
	close $script;
	chmod 0755,  "$root_dir/build/run_$name";

	link("$root_dir/build/run_$name", "$inst_dir/run_$name") if (!$opt_skip_install);
}


sub create_service {
	my (%args) = @_;

	my @dirs;
	if ( $args{user} ) {
		@dirs = ($ENV{'HOME'}, ".config", "systemd", "user");
	}


	mkdir_path(@dirs);

	my $unit_path = join_path(@dirs, $args{name} . ".service");

	open(my $serv, '>', $unit_path) or fatal("Can't create $unit_path: $!");
	print $serv "[Unit]\n";
	print $serv "Description=$args{desc}\n";
	print $serv "After=network.target\n";
	print $serv "\n";
	print $serv "[Service]\n";
	print $serv "WorkingDirectory=$root_dir/build/$args{name}\n";
	print $serv "Environment=\"LD_LIBRARY_PATH=$root_dir/build/$args{name}\"\n";
	print $serv "Environment=\"HIFI_ENVIRONMENT=production\"\n";
	print $serv "ExecStart=$root_dir/build/$args{name}/$args{name} " . join(' ', @{$args{args}}) . "\n";
	print $serv "Restart=on-failure\n";
	print $serv "RestartSec=5s\n";
	print $serv "\n";
	print $serv "[Install]\n";

	if ( $args{user} ) {
		print $serv "WantedBy=default.target\n";
	} else {
		print $serv "WantedBy=multi-user.target\n";
	}

	close $serv;
}


sub mkdir_path {
	my (@parts) = @_;

	if (scalar @parts == 1) {
		# If we only have one argument, assume it's a concatenated path
		@parts = File::Spec->splitdir($parts[0]);
	}

	my $path = "";

	while(@parts) {
		$path .= "/" if ($path || $parts[0] eq "");
		$path .= shift(@parts);
		if ( ! mkdir($path) ) {
			fatal("Can't create '$path': $! (mkpath " . join(';', @parts) . ")" ) unless ($!{EEXIST});
		}
	}
}

sub join_path {
	my (@parts) = @_;
	return join('/', @parts);
}

sub sudo_run {
	my (@command) = @_;

	important("Root privileges are needed to run the following command:\n");
	important("\t" . join(' ', @command) . "\n");
	important("Please enter your password to continue\n\n");

	run("sudo", @command);
}

sub read_from_cmd {
	my (@command) = @_;
	my $opts = {};

	if ( ref($command[0]) eq "HASH" ) {
		$opts = shift(@command);
	}

	$opts->{keep_buf} = 1;

	return run($opts, @command);
}

sub read_from_cmd_into_file {
	my ($filename, @cmd) = @_;
	my $text = read_from_cmd(@cmd);

	# die instead of fatal() here since this may be called from fatal.
	open(my $fh, '>', $filename) or die "Failed to create $filename: $!";
	print $fh $text;
	close $fh;
}



sub calculate_cores {
	my ($name, $mem_per_core) = @_;
	info("Checking how many cores to use for building $name... ");

	my $core_count =  grep { /^processor/ } readfile("/proc/cpuinfo");
	my ($mem_avail) = grep { /^MemAvailable/ } readfile("/proc/meminfo");

	info_ok("$core_count cores");

	$mem_avail =~ /:\s*(\d+)/;
	$mem_avail = $1;


	my $cores = $core_count;
	if ( $cores >= ($mem_avail / $mem_per_core )) {
		$cores = int($mem_avail / $mem_per_core);
		$cores = 1 unless ($cores);
		warning(", memory limited to $cores");

	}
	info_ok("\n");

	return $cores;
}

sub get_desktop {
	info("Detecting desktop location... ");

	my $desktop = read_from_cmd({ fail_ok => 1 }, "xdg-user-dir", "DESKTOP");
	if (!$desktop) {
		$desktop = "$ENV{HOME}/Desktop";
	}

	chomp $desktop;
	info_ok($desktop . "\n");

	return $desktop;
}


sub readfile {
	my ($file) = @_;
	debug("READFILE: $file\n");

	open(my $fh, $file) or fatal("Can't open $file: $!");
	my @data = <$fh>;
	chomp @data;
	close $fh;

	debug(join("\n", @data));
	return @data;
}

sub get_source_from_git {
	my ($url, $destdir, $tag, %opts) = @_;

	info("Getting source from git $url ($tag)...\n");

	if ( ! -d "$root_dir/$destdir/.git" ) {
		clone_repo($url, $destdir, $tag, %opts);
	} else {
		info("Checking if updating the existing source is possible... ");

		chdir("$root_dir/$destdir") or fatal("Can't chdir into $root_dir/$destdir: $!");
		my @remotes = read_from_cmd("git", "remote", "-v");
		my $no_update;

		foreach my $line (@remotes) {
			my ($name, $remote) = split(/\s+/, $line);
			if ( $name ne "origin" ) {
				info_ok("no, additional remote $name present.\n");
				$no_update=1;
				last;
			}

			if ( $remote ne $url ) {
				info_ok("no, url '$remote' differs from wanted URL.\n");
				$no_update=1;
				last;
			}
		}

		chdir($root_dir);

		if ( $no_update ) {
			clone_repo($url, $destdir, $tag, %opts);
		} else {
			info_ok("yes\n");
			update_repo($url, $destdir, $tag, %opts);
		}
	}
}

sub clone_repo {
	my ($url, $destdir, $tag, %opts) = @_;
	my @git_extra_args;

	info("Checking $root_dir/$destdir... ");
	if ( -d "$root_dir/$destdir" ) {
		run("rm", "-rf", "$root_dir/$destdir");
		info_ok("deleted for a clean clone.\n");
	} else {
		info_ok("ok.\n");
	}

	if ( exists $opts{git_args} ) {
		@git_extra_args = @{$opts{git_args}};
	}

	run("git", "clone", "--progress", "--recursive", $url, "$root_dir/$destdir", "-b", $tag, "--single-branch"); # "@git_extra_args);
}

sub update_repo {
	my ($url, $destdir, $tag, %opts) = @_;

	if ( ! -d "$root_dir/$destdir/.git" ) {
		fatal("Can't update $root_dir/$destdir: there doesn't seem to be a git repo there!");
	}

	info_ok("Already cloned, updating...\n");

	if ( !$opt_keep_source ) {
		chdir("$root_dir/$destdir");
		run("git", "fetch", "origin", "$tag:refs/remotes/origin/$tag");
		run("git", "submodule", "update", "-f", "--init", "--recursive") unless ($opts{'no_submodules'});
		run("git", "clean", "-f");
		run("git", "checkout", "origin/$tag");
	}

}

sub edit_qt_conf {
	my ($file, %values) = @_;

	info("Editing qt config file $file... ");

	open(my $rh, "<", $file) or fatal("Failed to open $file: $!");
	open(my $wh, ">", "$file.new") or fatal("Failed to create $file.new: $!");
	while(my $line = <$rh>) {
		if ( $line =~ /^(\w+)\s*=\s*(.*?)$/ && exists $values{$1} ) {
			print $wh "$1=$values{$1}\n";
			delete $values{$1};
		} else {
			print $wh $line;
		}
	}

	close $wh;
	close $rh;

	rename("$file.new", $file) or fatal("Failed to rename $file.new to $file: $!");

	if ( %values ) {
		fatal("Failed to find settings when editing $file: " . join(', ', keys %values));
	}

	info_ok("done.\n");
}


sub find_lib_dir {
	my ($lib, @paths) = @_;
	info("Trying to find where $lib is... ");
	foreach my $dir (@paths) {
		if ( -f "$dir/$lib" || -l "$dir/$lib" ) {
			info_ok("Found in $dir\n");
			return $dir;
		}
	}

	fatal("Failed! Looked in: " . join(', ', @paths));
}

sub find_qt_cmake_dir {
	info("Trying to find where system Qt is... ");
	foreach my $dir (@system_qt_paths) {
		if ( -d "$dir/Qt5WebEngine" ) {
			info_ok("$dir\n");
			return $dir;
		}
	}

	fatal("Failed! Looked in " . join(', ', @system_qt_paths));
}

sub del_dir {
	my ($dir) = @_;

	info("Ensuring $dir doesn't exist... ");
	if ( -d "$dir" ) {
		run("rm", "-rf", $dir);
		info_ok("deleted.\n");
	} else {
		info_ok("ok.\n");
	}
}


sub check_qt_install {
	info("Checking whether Qt is already installed... ");

	if ( -f "$root_dir/qt5-install/lib/libQt5Widgets.so" || -l "$root_dir/qt5-install/lib/libQt5Widgets.so" ) {
		info_ok("yes.\n");
		return 1;
	} else {
		info_ok("no.\n");
		return 0;
	}
}

sub ver_parse {
	my ($ver) = @_;
	my ($maj, $min, $rev) = split(/\./, $ver);
	return ($maj * 1000000) + ($min*1000) + $rev;
}


sub check_qt_webengine {
	# This checks if QtWebEngine is going to be built, and if any required dependencies
	# are missing. This works by parsing config.summary, which seems very clunky.
	#
	# This is necessary because Qt will build fine without WebEngine, but then
	# the interface will fail to build.
	#
	# Improvements are welcome.

	info("Checking QtWebEngine configuration... ");

	open(my $fh, '<', "$root_dir/qt5-build/config.summary")
		or fatal("Can't open $root_dir/qt5-build/config.summary: $!");


	# Number of sections we need to find in the output to make sure the
	# config came out okay. This varies by Qt version. We find 3 for 5.14
	# and below, and only 2 for 5.15.
	my $sections_needed = $DD->{qt_check_sections} // 3;
	if ( ver_parse($DD->{qt_version}) >= ver_parse('5.15.0') ) {
		$sections_needed = 2;
		debug("Using $sections_needed for section check for Qt 5.15");
	}

	my $sections_found = 0;
	my $lines_found = 0;

	my $in_webengine;
	my $in_req;
	my $in_req_sys_qpa;
	my @missing;


	while(my $line = <$fh>) {
		chomp $line;


		if ( $line =~ /^WARNING: (.*?) is required to build QtWebEngine/ ) {
			push @missing, $1;
		}

		if ( $line !~ /^\s+/ || $line =~ /^\s*$/ ) {
			# Line doesn't start with a space, or the line is empty
			undef $in_webengine;
			undef $in_req;
		}

		if ( $line !~ /^\s{4}/ ) {
			undef $in_req;
		}

		# The second option is for Qt 5.14
		if ( $line =~ /^(Qt WebEngine|Qt WebEngine Build Tools):/ ) {
			$in_webengine = 1;
			$sections_found++;
			next;
		}

		# The second option is for Qt 5.14
		if ( $in_webengine && $line =~ /^  (Required|QtWebEngine required)/ ) {
			$in_req = 1;
			$sections_found++;
			next;
		}

		if ( $in_req ) {
			if ( $line =~ /^\s*(.*?)[ .]+(\w+)$/ ) {
				$lines_found++;

				my ( $dep, $val ) = ($1, $2);
				if ( $val =~ /no/i ) {
					push @missing, $dep;
				}
			} else {
				fatal("Failed to parse line '$line' in $root_dir/qt5-build/config.summary");
			}
		}

	}
	close $fh;

	if ($sections_found < $sections_needed) {
		fatal("Failed to parse $root_dir/qt5-build/config.summary: only $sections_found of $sections_needed sections were found");
	}

	if ($lines_found < 5) {
		# There are 11 lines in Qt 5.12.6.
		# We don't care about the exact amount, just that something matched and the result is plausible.
		fatal("Failed to parse $root_dir/qt5-build/config.summary: only $lines_found lines were found inside the sections");
	}


	if (@missing) {
		fatal("Missing QtWebEngine dependencies: " . join(', ', @missing));
	} else {
		info_ok("ok.\n");
	}
}




sub get_supported {
	foreach my $k ( sort keys %$data ) {
		print "$k\n";
	}
	exit(0);
}

sub get_conf {
	my ($key, $dist) = @_;
	unless(exists $data->{$dist}) {
		print STDERR "No such distribution: '$dist'. Try $0 --get-supported\n";
		exit(1);
	}

	unless( exists $data->{$dist}->{$key} ) {
		print STDERR "$key not defined in the config for distro '$dist'\n";
		exit(1);
	}


	if ( ref($data->{$dist}->{$key}) eq "ARRAY" ) {
		foreach my $pkg ( @{ $data->{$dist}->{$key} } ) {
			print "$pkg\n";
		}
	} else {
		print $data->{$dist}->{$key} . "\n";
	}

	exit(0);
}

sub make_pkglist {
	my @packages;
	while(my $line = <STDIN>) {
		chomp $line;
		my @pkgs = grep { $_ } split(/\s+/, $line);
		push @packages, @pkgs;
	}

	foreach my $pkg ( sort @packages ) {
		print "\t\t\t\'$pkg',\n";
	}

	exit(0);
}

sub parse_build_option {
	my ($optval) = @_;


	# Valid aliases (names for groups of targets)
	my @all_aliases = qw( all client server );

	my %all_valid = map { $_ => 1 } (@all_aliases, keys %$all_targets);
	my %split = map { $_ => 1 } split(/,/, $optval);
	my @out;

	if ( $split{all} ) {
		delete $split{all};
		foreach my $t (keys %$all_targets) {
			$split{$t} = 1;
		}
	}

	if ( $split{client} ) {
		delete $split{client};
		$split{'jsdoc'}            = 1; # Horrible hack to deal with vircadia/vircadia#513
		$split{'interface'}        = 1;
	}

	if ( $split{server} ) {
		delete $split{server};
		$split{'domain-server'}     = 1;
		$split{'assignment-client'} = 1;
	}

	if ( $split{'jsdoc'} ) {
		# Horrible hack to deal with vircadia/vircadia#513 -- part 2
		# ensure we build jsdoc first
		push @out, 'jsdoc';
		delete $split{jsdoc};
	}

	foreach my $k ( keys %all_valid ) {
		push @out, $k if exists $split{$k};
		delete $split{$k};
	}

	debug("Parsed build targets: " . join(', ', @out));

	if ( %split ) {
		my $bad = join(', ', keys %split);

		print STDERR "Bad value '$bad' for build option, only these values are valid:\n";
		print STDERR  join(', ', sort keys %all_valid) . "\n\n";
		print STDERR "You probably want one of:\n";
		print STDERR "\tclient      Build the graphical desktop client. This is the default.\n";
		print STDERR "\t            Choosing this option builds the 'interface' target\n\n";
		print STDERR "\tserver      Build the components needed to create a server (domain)\n";
		print STDERR "\t            Choosing this option builds domain-server and assignment-client\n\n";
		print STDERR "\tall         Build everything, including development and testing tools\n";
		print STDERR "\nTry $0 --help for more information on the command-line arguments\n";
		exit(1);
	}

	return @out;
}


##########################################################################
# AppImage
##########################################################################

#sub get_library_paths {
#	my $ret;
#
#	foreach my $dir (@ext_lib_paths) {
#		$ret .= ":" if ($ret);
#		$ret .= "$root/$dir";
#
#		if ( ! -d "$root/$dir" ) {
#			fatal("Can't find library path: $root/$dir");
#		}
#	}
#
#	return $ret;
#}

sub file_is_under_dir {
	my ($file, $dir) = @_;
	return substr($file, 0, length($dir)) eq $dir;
}

sub download_appimage_tool {
	my $tool_path = "$root_dir/appimagetool.${appimagetool_release}";

	if (!-f $tool_path) {
		run("curl", "-L", $appimagetool_url, "-o", $tool_path);
		chmod 0755, $tool_path;
	}
}

sub install_into_appimage {
	# This is a bit of a mess. The AppImage tools want a normal, well-behaved
	# application, and choke on all this qt5-install and vcpkg weirdness.
	#
	# They also want the binary to be in usr/bin, rather than where we have it.
	#
	# So we skip all of that, generate a non-standard layout by hand, and just
	# package it up.
	#
	# This should get a lot nicer once the Vircadia tree gets a better packaging
	# process that makes things go in the places they're supposed to on a normal
	# Linux system. But meanwhile, we have this.

	info("\n\n");
	important("############################################################\n");
	important("# Installing into AppImage\n");
	important("############################################################\n");
	info("\n");

	# Another horrible hack for vircadia/vircadia#513
	@build_list = grep { !/jsdoc/ } @build_list;

	if ( scalar(@build_list) > 1 ) {
		fatal("Can't create AppImage of more than one target, skipping\n");
		return;
	}

	my ($target) = @build_list;
	if ( $all_targets->{$target}->{is_service} ) {
		fatal("Can't create AppImage for a systemd service, skipping\n");
		return;
	}

	my $appimage_base    = "$root_dir/Vircadia.AppImage";
	my $appimage_instdir = "$appimage_base/vircadia";
	my $appimage_qtdir   = "$appimage_base/qt5-install";
	my $tool_path        = "$root_dir/appimagetool.${appimagetool_release}";

	# We want to start from scratch every time
	if ( -d "$appimage_base" ) {
		info("Cleaning $appimage_base... ");
		run("rm", "-rf", $appimage_base);
		info_ok("done.\n");
	}

	# We create this structure here:
	# AppImage/qt5-install -- qt dir
	# AppImage/vircadia/interface/interface -- binary
	#
	# This ensures it goes together just like it does in
	# $VircadiaRoot/qt5-install and $VircadiaRoot/install_*
	# and the relative paths keep working.
	#
	# Also, unlike with the install, for AppImage generation, we will modify the Qt libraries,
	# so the directory must be copied rather than linked.

	info("Copying Vircadia files to $appimage_instdir\n");
	mkdir($appimage_instdir);

	find({ follow      => 1,
	       follow_skip => 2,
	       wanted      => sub { install_search_func("$root_dir/build", $appimage_instdir, "copy") }},
	       "$root_dir/build");

	# Clear line
	info( "\r" . (" " x $prev_len) . "\r");

	info("Copying Qt5 files to $appimage_qtdir\n");
	run("cp", "-rdp", "$root_dir/qt5-install", $appimage_qtdir);

	# Clear line
	info( "\r" . (" " x $prev_len) . "\r");

	info("Copied : "); info_ok("$inst_copied\n");
	info("Skipped: "); info_ok("$inst_skipped\n");
	info("Deleted: "); info_ok("$inst_deleted\n");
	info("\n");

	info("Creating icons... ");
	run("convert", "$root_dir/source/interface/icon/interface.ico", "$appimage_base/interface.png");
	my $max_size = 0;
	foreach my $icon (glob("$appimage_base/interface-*.png")) {
		my $type = read_from_cmd("file", "-b", $icon);
		chomp $type;
		my ($png, $res, $color) = split(/\s*,\s*/, $type);
		$res =~ s/\s*//g;
		my $size = split(/x/, $res);

		info_ok("$res, ");
		my $icon_path     = "$appimage_base/usr/share/icons/hicolor/$res/apps";
		my $icon_filename = "$icon_path/Vircadia.png";

		mkdir_path($icon_path);
		rename($icon, $icon_filename);

		if ( $max_size < $size ) {
			$max_size = $size;
			symlink("usr/share/icons/hicolor/$res/apps/Vircadia.png", "$appimage_base/Vircadia.png");
		}

	}
	info_ok("done.\n");

	mkdir_path("$appimage_base/usr/bin");
	symlink("../../vircadia/interface/interface", "$appimage_base/usr/bin/Vircadia");

	create_desktop_file("$appimage_base/Vircadia.desktop",
	                    "Vircadia", "Vircadia");

	info("Finding library dependencies...\n");
	my @dep_list = ldd("$root_dir/build/$target/$target");

	info("Finding plugins...\n");
	foreach my $plugin_dir ("$root_dir/qt5-install/plugins/platforms", "$root_dir/build/$target/plugins") {
		info("Trying $plugin_dir... ");
		if ( -d "$plugin_dir" ) {
			info_ok("found, scanning...\n");

			find(sub {
				my $file = $File::Find::name;
				return unless $file =~ /\.so$/;
				push @dep_list, ldd($File::Find::name);
				}, $plugin_dir);
			info_ok("done.\n");
		} else {
			warning("not found, skipping\n");
		}
	}

	my %deps = map { $_ => 1 } @dep_list;

	info("Copying missing system libraries... ");
	mkdir_path("$appimage_base/usr/lib64");

	foreach my $dep (sort keys %deps) {

		# We're copying dependencies that are not located inside the build directory,
		# as those have been dealt with earlier.
		#
		# We make an exception here about dependencies that remain in vcpkg, because otherwise
		# those would not be copied at all into the AppImage.
		if ( file_is_under_dir($dep, $root_dir) && !file_is_under_dir($dep, "$root_dir/vcpkg") ) {
			info("-");
			next;
		}

		info(".");

		# The dependency list we get points to the actual filename the binary wants.
		# If this turns out to be a symlink, then we copy the file it points to, and
		# create a symlink at the destination.
		if ( -l $dep ) {
			cp($dep, "$appimage_base/usr/lib64/" . basename(readlink($dep)));
			symlink(basename(readlink($dep)), "$appimage_base/usr/lib64/" . basename($dep));
		} else {
			cp($dep, "$appimage_base/usr/lib64/");
		}
	}

	if (!$opt_sys_qt && glob("$appimage_base/usr/lib64/libQt*")) {
		# If anything gets compiled against system qt, the likely outcome
		# is weird issues, such as the binary hanging on startup, probably due to multiple
		# incompatible versions of Qt being loaded by interface.
		#
		# So far this has been a possible issue with libquazip
		my $msg = "Sanity check failed: something has been built against system Qt, even though system Qt is not enabled.\n";
		$msg   .= "The following incorrect libraries have been found as dependencies:\n";
		$msg   .= join(', ', glob("$appimage_base/usr/lib64/libQt*"));

		fatal($msg);
	}

	chmod(0755, glob("$appimage_base/usr/lib64/*"));

	info_ok("done.\n");

	info("Adjusting rpath...");
	find({ follow      => 1,
	       follow_skip => 2,
	       wanted      => sub { add_lib_path_search_func("$appimage_base/usr/lib64/") }},
	       $appimage_base);

	info_ok("done.\n");

	# Qt needs to be pointed to where its own files are
	info("Creating qt.conf...");
	open(my $qtconf, '>', "$appimage_base/vircadia/interface/qt.conf") or fatal("Can't create qt.conf: $!");
	print $qtconf "[Paths]\n";
	print $qtconf "Prefix=../../qt5-install/\n";
	close $qtconf;

	info("Creating AppRun... ");
	symlink("vircadia/interface/interface", "$appimage_base/AppRun");
	info_ok("done.\n");

	# AppStream metadata support is fairly broken in AppImages.
	# We are working around this by making sure that appstream-util is NOT available to check the metadata.
	# See https://github.com/AppImage/AppImageKit/issues/603
	info("Checking for appstream-util... ");
	if ( system("appstream-util") == 0 ) {
		warning("appstream-util found. Please uninstall appstream-util to be able to include AppStream metadata. See https://github.com/AppImage/AppImageKit/issues/603");
	} else {
		info_ok("appstream-util not found. Adding AppStream metadata.");
		create_appimage_metadata("$appimage_base/usr/share/metainfo/Vircadia.appdata.xml");
	}
	info("Creating AppImage...");
	chdir($root_dir);
	run($tool_path, $appimage_base);
}

sub create_appimage_metadata {
	my ($filename) = @_;

	info("Creating metadata... ");

	my $dir = dirname($filename);
	mkdir_path($dir);

	open(my $fh, '>', $filename) or fatal("Can't create $filename: $!");
	print $fh <<METADATA;
<?xml version="1.0" encoding="UTF-8"?>
<!-- Copyright 2021 Dale Glass <dale\@daleglass.net> -->
<component type="desktop-application">
  <id>com.vircadia.interface</id>
  <metadata_license>FSFAP</metadata_license>
  <project_license>Apache-2.0</project_license>
  <name>Vircadia</name>
  <summary>Vircadia Metaverse client</summary>

  <description>
    <p>
      Vircadia is the Open Source continuation of the High Fidelity metaverse.
    </p>
  </description>
  <categories>
      <category>Graphics</category>
      <category>Network</category>
      <category>AudioVideo</category>
  </categories>
  <screenshots>
    <screenshot type="default">
      <caption>Vircadia running on Linux Mint 19.3</caption>
      <image>https://docs.vircadia.com/_images/29th_september_interface_linux.jpg</image>
    </screenshot>
    <screenshot>
      <caption>Maker Meeting on the "El Papa Viejo"</caption>
      <image>https://docs.vircadia.com/_images/el_papa_viejo.jpg</image>
    </screenshot>
    <screenshot>
      <caption>Dale Glass speaking at the Developer Meeting</caption>
      <image>https://docs.vircadia.com/_images/vircadia-snap-by-RyanLi-on-2020-09-20_02-45-59.jpg</image>
    </screenshot>
    <screenshot>
      <caption>Mannequin army</caption>
      <image>https://docs.vircadia.com/_images/vircadia-snap-by-Revofire-on-2020-08-13_17-21-43.jpg</image>
    </screenshot>
  </screenshots>

  <url type="homepage">https://vircadia.com/</url>
  <url type="bugtracker">https://github.com/vircadia/vircadia/issues</url>
  <url type="help">https://docs.vircadia.com/</url>
  <url type="translate">https://weblate.vircadia.dev/</url>
  <project_group>Internet</project_group>

  <provides>
    <binary>Vircadia</binary>
  </provides>

<!--
  <releases>
    <release version="3.12.2" date="2013-04-12">
      <description>
        <p>Fixes issues X, Y and Z</p>
      </description>
    </release>
  </releases>
  <developer_name>Vircadia</developer_name>
-->
</component>
METADATA
	close $fh;

	info_ok("done.\n");
}


sub ldd {
	my ($binary, $seen, $depth) = @_;
	my @deps;
	my @rec_deps;
	my $binary_dir;

	$binary     = abs_path($binary);
	$binary_dir = dirname($binary);
	$seen       //= {};
	$depth      //= 0;

	return if exists $seen->{$binary};
	if (!-e "$binary") {
		fatal("Can't run ldd on '$binary': file not found");
	}

	info("  " x $depth);
	info("$binary...");

	# We force ldd to consider the binary's directory as a location for dependencies,
	# even if the rpath isn't set accordingly, as we're going to add that afterwards
	# anyway, when we copy things into the AppImage dir.
	my $orig_ld_path = $ENV{LD_LIBRARY_PATH};
	$ENV{LD_LIBRARY_PATH} .= ":$binary_dir";
	my @lines = read_from_cmd("ldd", $binary);
	$ENV{LD_LIBRARY_PATH} = $orig_ld_path;

	foreach my $line (@lines) {
		chomp $line;

		next unless ($line =~ /=>/);
		my ($soname, $path) = split(/\s*=>\s*/, $line);
		$soname =~ s/^\s+//;
		$soname =~ s/\s+$//;

		$path =~ s/\s+\([0-9a-fA-Fx]*\)//;

		if ( is_system($path) ) {
			debug("$soname: excluded\n");
			next;
		}

		debug("$soname => $path\n");

		if ( $path eq "not found" ) {
			fatal("Can't find library '$soname' for binary '$binary'");
		}

		if ( $path =~ /libQt5Core.so.5.13.2/ ) {
			die "$binary uses $path";
		}

		# abs_path canonicalizes a path, but that includes resolving
		# symlinks. We don't want that. We want the original filename
		# the binary is referencing.
		my $orig_filename=basename($path);
		$path = File::Spec->catfile(dirname(abs_path($path)), $orig_filename);

		if ( $path =~ /libQt5Core.so.5.13.2/ ) {
			die "$binary uses $path";
		}
		push @deps, $path;
		info(".");
	}

	$seen->{$binary}=1;
	info_ok(" done.\n");

	foreach my $dep (@deps) {
		push @rec_deps, ldd($dep, $seen, $depth+1);
	}

	push @deps, @rec_deps;
	return @deps;
}

sub is_system {
	my ($path) = @_;

	foreach my $re (@excluded_system_libs) {
		my $filename = basename($path);
		#die "$filename is excluded" if ( $filename =~ /$re/);
		return 1 if ( $filename =~ /$re/ );
	#	if ( $filename =~ /libc/ ) {
	#		warn "$filename passed check $re";
	#	}
	}

	return 0;
}


# For AppImage, all library paths have to be relative.
sub add_lib_path_search_func {
	my ($libdir) = @_;
	my $abspath = $File::Find::name;
	my $absdir  = $File::Find::dir;

	if ( -f $abspath && -x $abspath && !-l $abspath && is_elf($abspath) )  {
		my $rel_libpath = File::Spec->abs2rel($libdir, $absdir);

		my $rpath = read_from_cmd("patchelf", "--print-rpath", $abspath);
		chomp $rpath;
		my %rpaths = map { $_ => 1 } split(/:/, $rpath);

		$rpaths{'$ORIGIN'} = 1;

		if ( $rel_libpath ne "." ) {
			$rpaths{'$ORIGIN/' . $rel_libpath} = 1;
		}

		run("patchelf", "--set-rpath", join(':', sort keys %rpaths), $abspath);
		info(".");
	}
}


sub help {
	my $retval = shift // 0;

	print <<HELP;

$0 [options]
Downloads, compiles and installs Vircadia.

Options:
	-A, --make-appimage     Create an AppImage
	-B, --build-qt          Built Qt even if there's a binery package
	-C, --collect-info      Collect additional info for debugging
	-D, --distro DIST       Set the distribution
	-d, --destdir DIR       Set the installation directory
	-h, --help              Shows this text
	-j, --cores NUM         Use NUM cores during main build
	-J, --qt-cores NUM      Use NUM cores during Qt build
	-k, --keep-source       Don't overwrite the current source tree
	-r, --repo REPO         Set the repository to REPO
	-t, --tag TAG           Set the tag to TAG
	-y, --auto              Run without asking any questions
	--qt-debug              Build Qt in debug mode
	--qt-debug-info         Build Qt with debug symbols in release mode

Custom mode options:

This script is intended to be user friendly and as automatic as possible, so
it has embedded presets for a number of distributions. However, it can be made
to work without them.

	--get-supported            Lists the distributions that are supported
	--get-source-deps DIST     Lists the packages needed to build the source on
	                           distro DIST.
	--get-system-qt-deps DIST  Lists the packages needed to build against
                               system Qt on distro DIST
	--get-qt-deps DIST         Lists the packages needed to build Qt on distro
	                           DIST.
	--get-qt-version DIST      Outputs the Qt version that will be used if Qt
	                           is built from source on disto DIST.
	--get-qt-patches DIST      Lists the patches that will be applied if Qt
	                           is built from source on distro DIST.
	--make-pkglist             Reads a list of package names from STDIN and
	                           outputs them in a format suitable for pasting
	                           into the script's source code.

HELP


	exit(1);
	exit($retval);
}
